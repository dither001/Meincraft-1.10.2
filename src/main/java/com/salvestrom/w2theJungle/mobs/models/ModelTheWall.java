// Date: 15/09/2014 21:18:29
// Template version 1.1
// Java generated by Techne
// Keep in mind that you still need to fill in some blanks
// - ZeuX

package com.salvestrom.w2theJungle.mobs.models;

import net.minecraft.client.model.ModelBase;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.MathHelper;

import com.salvestrom.w2theJungle.mobs.entity.EntityTheWall;

public class ModelTheWall extends ModelBase
{
  //fields
    public ModelRenderer upperbody;
    public ModelRenderer lowerbody;
    //fw - fate weave armour
    ModelRenderer fwupperbody;
    
    ModelRenderer upperRshoulder;
    ModelRenderer upperLshoulder;

    ModelRenderer gemholder;
    ModelRenderer gem;
    ModelRenderer upperLleg;
    ModelRenderer upperRleg;
    ModelRenderer lowerLleg;
    ModelRenderer lowerRleg;
    ModelRenderer headplate;
    ModelRenderer head;
    ModelRenderer neck;
    ModelRenderer jaw;
    ModelRenderer jawLfixture;
    ModelRenderer jawRfixture;
    ModelRenderer toothR;
    ModelRenderer toothL;
    ModelRenderer upperLarm;    ModelRenderer lowerLarm;
    ModelRenderer handplateL;
    ModelRenderer upperRarm;    ModelRenderer lowerRarm;
    ModelRenderer handplateR;
    ModelRenderer armbraceupperL;
    ModelRenderer legbraceL;
    ModelRenderer armbraceL;
    ModelRenderer armbraceupperR;
    ModelRenderer armbraceR;
    ModelRenderer legbraceR;
    ModelRenderer lat;
    
    ModelRenderer arrowLauncher;
    ModelRenderer arrowLauncher2;

    
  public ModelTheWall()
  {
    textureWidth = 256;
    textureHeight = 256;
    
    fwupperbody = new ModelRenderer(this, 0, 162);
    fwupperbody.addBox(-19.5F, -0.5F, -9.5F, 39, 18, 20);
    fwupperbody.setRotationPoint(0F, 0F, 0F); // 0 -36 0
    fwupperbody.setTextureSize(256, 256);
    fwupperbody.mirror = true;
    setRotation(fwupperbody, 0F, 0F, 0F);
    
      upperbody = new ModelRenderer(this, 0, 125);
      upperbody.addBox(-19F, 0F, -9F, 38, 17, 19);
      upperbody.setRotationPoint(0F, -30F, 0F); // 0 -36 0
      upperbody.setTextureSize(256, 256);
      upperbody.mirror = true;
      setRotation(upperbody, 0F, 0F, 0F);
      gemholder = new ModelRenderer(this, 57, 47);
      gemholder.addBox(-2F, 0F, 0F, 4, 5, 2);
      gemholder.setRotationPoint(0F, 6F, -9.7F); //-9.5 -=- 0 -30 -9.5
      gemholder.setTextureSize(256, 256);
      gemholder.mirror = true;
      setRotation(gemholder, 0F, 0F, 0F);
      gem = new ModelRenderer(this, 57, 55);
      gem.addBox(-1.5F, 0.52F, 0F, 3, 4, 2);
      gem.setRotationPoint(0F, 0F, -0.4F); //was -0.5  -- 0 -30 -10 
      gem.setTextureSize(256, 256);
      gem.mirror = true;
      setRotation(gem, 0F, 0F, 0F);
      lowerbody = new ModelRenderer(this, 0, 94);
      lowerbody.addBox(-14F, -13F, -8F, 28, 14, 16); // -14, 0 -8
      lowerbody.setRotationPoint(0F, -6F, 0F); //0, -19, 0
      lowerbody.setTextureSize(256, 256);
      lowerbody.mirror = true;
      setRotation(lowerbody, 0F, 0F, 0F);
      upperLleg = new ModelRenderer(this, 0, 33);
      upperLleg.mirror = true;
      upperLleg.addBox(-7F, 0F, -7F, 14, 14, 14);
      upperLleg.setRotationPoint(10F, 0F, 0F); //10 -6 0
      upperLleg.setTextureSize(256, 256);
      upperLleg.mirror = true;
      setRotation(upperLleg, 0F, 0F, 0F);
      upperRleg = new ModelRenderer(this, 0, 33);
      upperRleg.addBox(-7F, 0F, -7F, 14, 14, 14);
      upperRleg.setRotationPoint(-10F, 0F, 0F); //-10 -6 0
      upperRleg.setTextureSize(256, 256);
      upperRleg.mirror = true;
      setRotation(upperRleg, 0F, 0F, 0F);
      lowerLleg = new ModelRenderer(this, 0, 0);
      lowerLleg.mirror = true;
      lowerLleg.addBox(-8F, 0F, -4F, 16, 16, 16);
      lowerLleg.setRotationPoint(0F, 14F, -4F); // 10 8 0
      lowerLleg.setTextureSize(256, 256);
      lowerLleg.mirror = true;
      setRotation(lowerLleg, 0F, 0F, 0F);
      legbraceL = new ModelRenderer(this, 183, 0);
      legbraceL.mirror = true;
      legbraceL.addBox(-2F, -19F, -3F, 3, 19, 6);
      legbraceL.setRotationPoint(9F, 16F, 4F);
      legbraceL.setTextureSize(256, 256);
      legbraceL.mirror = true;
      setRotation(legbraceL, 0F, 0F, 0F);

      lowerRleg = new ModelRenderer(this, 0, 0);
      lowerRleg.addBox(-8F, 0F, -4F, 16, 16, 16);
      lowerRleg.setRotationPoint(0F, 14F, -4F); //-10 8 0
      lowerRleg.setTextureSize(256, 256);
      lowerRleg.mirror = true;
      setRotation(lowerRleg, 0F, 0F, 0F);
      legbraceR = new ModelRenderer(this, 183, 0);
      legbraceR.addBox(-1F, -19F, -3F, 3, 19, 6);
      legbraceR.setRotationPoint(-9F, 16F, 4F);
      legbraceR.setTextureSize(256, 256);
      legbraceR.mirror = true;
      setRotation(legbraceR, 0F, 0F, 0F);
      
      headplate = new ModelRenderer(this, 70, 0);
      headplate.addBox(-7F, -4F, -7F, 14, 5, 15);
      headplate.setRotationPoint(0F, -6F, -1F);
      headplate.setTextureSize(256, 256);
      headplate.mirror = true;
      setRotation(headplate, 0F, 0F, 0F);
      head = new ModelRenderer(this, 0, 65);
      head.addBox(-6F, -11F, -6F, 12, 13, 12);
      head.setRotationPoint(0F, -11F, -1F); //neck was 0 -28 -2 head: 0 -39 -2
      head.setTextureSize(256, 256);
      head.mirror = true;
      setRotation(head, 0F, 0F, 0F);
      neck = new ModelRenderer(this, 129, 34);
      neck.addBox(-5F, -12F, -5F, 10, 4, 9); //neck box height lowered from 12 to 4. upperbody:0 -36 0
      neck.setRotationPoint(0F, 8F, -1F); //lowered from 36 to 28 to accommodate above change.
      neck.setTextureSize(256, 256);
      neck.mirror = true;
      setRotation(neck, 0F, 0F, 0F);
      jaw = new ModelRenderer(this, 130, 0);
      jaw.addBox(-7F, -4F, -6F, 14, 6, 12);
      jaw.setRotationPoint(0F, 2F, -2F); //change to allow jaw to hinge
      jaw.setTextureSize(256, 256);
      jaw.mirror = true;
      setRotation(jaw, 0F, 0F, 0F);
      jawLfixture = new ModelRenderer(this, 57, 38);
      jawLfixture.addBox(-1F, -1F, -1F, 1, 4, 4);
      jawLfixture.setRotationPoint(-6F, -4F, 0F); //head: 0 -39 -2
      jawLfixture.setTextureSize(256, 256);
      jawLfixture.mirror = true;
      setRotation(jawLfixture, 0F, 0F, 0F);
      jawRfixture = new ModelRenderer(this, 57, 38);
      jawRfixture.addBox(-0.0F, -1F, -1F, 1, 4, 4);
      jawRfixture.setRotationPoint(6F, -4F, 0F); //was 5.5 but nt visible
      jawRfixture.setTextureSize(256, 256);
      jawRfixture.mirror = true;
      setRotation(jawRfixture, 0F, 0F, 0F);
      toothR = new ModelRenderer(this, 57, 33);
      toothR.addBox(-1F, -1F, -1F, 2, 3, 1);
      toothR.setRotationPoint(-4F, -5F, -4F);
      toothR.setTextureSize(256, 256);
      toothR.mirror = true;
      setRotation(toothR, 0F, 0F, 0F);
      toothL = new ModelRenderer(this, 57, 33);
      toothL.addBox(-1F, -1F, -1F, 2, 3, 1);
      toothL.setRotationPoint(4F, -5F, -4F);
      toothL.setTextureSize(256, 256);
      toothL.mirror = true;
      setRotation(toothL, 0F, 0F, 0F);
      upperLarm = new ModelRenderer(this, 94, 65);
      upperLarm.mirror = true;
      upperLarm.addBox(0F, -4F, -4F, 9, 19, 8);
      upperLarm.setRotationPoint(19F, 6F, 0F); //19 -30 0 upperbody 0 -36 0
      upperLarm.setTextureSize(256, 256);
      upperLarm.mirror = true;
      setRotation(upperLarm, 0F, 0F, 0F);
      //upperLarm.mirror = false;
      lowerLarm = new ModelRenderer(this, 80, 34);
      lowerLarm.mirror = true;
      lowerLarm.addBox(-6F, 0F, -6F, 12, 15, 12);
      lowerLarm.setRotationPoint(5F, 13F, 0F); //24 -17 0  ul 19 -30 0
      lowerLarm.setTextureSize(256, 256);
      lowerLarm.mirror = true;
      setRotation(lowerLarm, 0F, 0F, 0F);
      handplateL = new ModelRenderer(this, 49, 65);
      handplateL.mirror = true;
      handplateL.addBox(-5F, 0F, -5F, 10, 2, 10);
      handplateL.setRotationPoint(0F, 14F, 0F);
      handplateL.setTextureSize(256, 256);
      handplateL.mirror = true;
      setRotation(handplateL, 0F, 0F, 0F);
      upperRarm = new ModelRenderer(this, 94, 65);
      upperRarm.addBox(-8F, -4F, -4F, 9, 19, 8);
      upperRarm.setRotationPoint(-20F, 6F, 0F); //-20 -30 0 //ub is 0 -36 0
      upperRarm.setTextureSize(256, 256);
      upperRarm.mirror = true;
      setRotation(upperRarm, 0F, 0F, 0F);
      lowerRarm = new ModelRenderer(this, 80, 34);
      lowerRarm.addBox(-6F, 0F, -6F, 12, 15, 12);
      lowerRarm.setRotationPoint(-4F, 13F, 0F); //-24 -17 0
      lowerRarm.setTextureSize(256, 256);
      lowerRarm.mirror = true;
      setRotation(lowerRarm, 0F, 0F, 0F);
      handplateR = new ModelRenderer(this, 49, 65);
      handplateR.addBox(-5F, 0F, -5F, 10, 2, 10);
      handplateR.setRotationPoint(0F, 14, 0F); //-24 -3 0
      handplateR.setTextureSize(256, 256);
      handplateR.mirror = true;
      setRotation(handplateR, 0F, 0F, 0F);
      armbraceupperL = new ModelRenderer(this, 183, 0);
      armbraceupperL.mirror = true;
      armbraceupperL.addBox(0F, -16F, -2F, 2, 16, 4);
      armbraceupperL.setRotationPoint(9F, 13F, 0F); //lla 24 -17 0 ula 19 -30 0
      armbraceupperL.setTextureSize(256, 256);
      armbraceupperL.mirror = true;
      setRotation(armbraceupperL, 0F, 0F, 0F);
      armbraceL = new ModelRenderer(this, 183, 0);
      armbraceL.mirror = true;
      armbraceL.addBox(-2F, -19F, -2F, 4, 19, 4);
      armbraceL.setRotationPoint(6F, 16F, 0F); //30 -1 0 left arm:24 -17 0
      armbraceL.setTextureSize(256, 256);
      armbraceL.mirror = true;
      setRotation(armbraceL, 0F, 0F, 0F);
      armbraceupperR = new ModelRenderer(this, 183, 0);
      armbraceupperR.addBox(0F, -16F, -2F, 2, 16, 4);
      armbraceupperR.setRotationPoint(-10F, 13F, 0F); // -30 -17 0 upper: -20 -30 0
      armbraceupperR.setTextureSize(256, 256);
      armbraceupperR.mirror = true;
      setRotation(armbraceupperR, 0F, 0F, 0F);
      armbraceR = new ModelRenderer(this, 183, 0);
      armbraceR.addBox(-1F, -19F, -2F, 4, 19, 4);
      armbraceR.setRotationPoint(-7F, 16F, 0F); // -31 -1 0 right arm: -24 -17 0
      armbraceR.setTextureSize(256, 256);
      armbraceR.mirror = true;
      setRotation(armbraceR, 0F, 0F, 0F);
      lat = new ModelRenderer(this, 129, 57);
      lat.addBox(0F, 0F, 1F, 34, 6, 10);
      lat.setRotationPoint(-17F, -13F, -4.5F); //-17 -19 -4.5   -=- lb0 -19 0
      lat.setTextureSize(256, 256);
      lat.mirror = true;
      setRotation(lat, 0F, 0F, 0F);
      
      arrowLauncher = new ModelRenderer(this, 204, 0);
      arrowLauncher.addBox(-2, -13, -5, 4, 13, 10);
      arrowLauncher.setRotationPoint(-2, -1, 0);
      arrowLauncher.setTextureSize(256, 256);
      setRotation(arrowLauncher, 0, 0, 0);
      
      arrowLauncher2 = new ModelRenderer(this, 204, 24);
      arrowLauncher2.addBox(-2, -13, -5, 4, 13, 10);
      arrowLauncher2.setRotationPoint(3, -1, 0);
      arrowLauncher2.setTextureSize(256, 256);
      setRotation(arrowLauncher2, 0, 0, 0);
      
      upperRshoulder = new ModelRenderer(this, 155,	74);
      upperRshoulder.addBox(-8, -7, -8, 15, 15, 16);
      upperRshoulder.setRotationPoint(-5, -4, 0); //TODO
      upperRshoulder.setTextureSize(256, 256);
      setRotation(upperRshoulder, 0, 0, 0);
      
      upperLshoulder = new ModelRenderer(this, 155,	74);
      upperLshoulder.mirror = true;
      upperLshoulder.addBox(-8, -7, -8, 15, 15, 16);
      upperLshoulder.setRotationPoint(6, -4, 0); //TODO
      upperLshoulder.setTextureSize(256, 256);
      setRotation(upperLshoulder, 0, 0, 0);
      
      
      this.neck.addChild(head);
      this.head.addChild(headplate);
      this.head.addChild(jaw);
      this.head.addChild(jawLfixture);
      this.head.addChild(jawRfixture);
      this.jaw.addChild(toothL);
      this.jaw.addChild(toothR);
      
      this.lowerbody.addChild(lat);
      this.lowerbody.addChild(upperbody);
      this.lowerbody.addChild(upperRleg);      this.lowerbody.addChild(upperLleg);
      this.upperLleg.addChild(lowerLleg);      this.upperRleg.addChild(lowerRleg);
      this.lowerLleg.addChild(legbraceL);		this.lowerRleg.addChild(legbraceR);
      
      this.upperbody.addChild(upperRarm); //this.upperbody.addChild(fwupperbody);
      this.lowerRarm.addChild(handplateR);	this.upperRarm.addChild(lowerRarm);
      this.lowerRarm.addChild(armbraceR);	this.upperRarm.addChild(armbraceupperR);
      this.upperRarm.addChild(upperRshoulder);
      this.upperLarm.addChild(upperLshoulder);

      
      this.armbraceR.addChild(arrowLauncher);
      this.armbraceL.addChild(arrowLauncher2);

      
      this.upperbody.addChild(upperLarm);
      this.lowerLarm.addChild(handplateL);	this.upperLarm.addChild(lowerLarm);
      this.lowerLarm.addChild(armbraceL);	this.upperLarm.addChild(armbraceupperL);
      
      this.upperbody.addChild(neck);
      this.upperbody.addChild(gemholder);
      this.gemholder.addChild(gem);
           
  }
  
  public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5)
  {
    super.render(entity, f, f1, f2, f3, f4, f5);
    setRotationAngles(f, f1, f2, f3, f4, f5, entity);
    lowerbody.render(f5);
  }
  
  private void setRotation(ModelRenderer model, float x, float y, float z)
  {
    model.rotateAngleX = x;
    model.rotateAngleY = y;
    model.rotateAngleZ = z;
  }

  public void setRotationAngles(float time, float motion, float age, float f3, float f4, float f5, Entity ntt)  {
	  
	  float rad = (float) (180/Math.PI);
	  float r = (float) 0.613306;

	  
	  EntityTheWall wall = (EntityTheWall)ntt;
	  
	  int t = wall.getAnimationTimer();
	  int a = wall.getAttackStatus();
	  
	  if(//wall.ticksExisted%20 == 0 &&
			  wall.worldObj.isRemote)
			   {
	  //System.out.println(a);
	 // System.out.println();
	  //System.out.println(wall.getAnimationTimer());
	  }
	  
	  this.head.rotateAngleY = f3 / (240F / (float)Math.PI);
	  this.head.rotateAngleX = f4 / (240F / (float)Math.PI);
	  this.neck.rotateAngleX = 0;
	  
	//walkies
	  this.upperRleg.rotateAngleX = (-1.5F * this.func_78172_a(time, 13.0F) * motion*0.7F) - this.lowerbody.rotateAngleX;
	  this.lowerLleg.rotateAngleX = -1.5F * this.func_78172_a(time, 13.0F) * motion*0.7F;
	  this.upperLleg.rotateAngleX = (1.5F * this.func_78172_a(time, 13.0F) * motion*0.7F)  - this.lowerbody.rotateAngleX;
	  this.lowerRleg.rotateAngleX = 1.5F * this.func_78172_a(time, 13.0F) * motion*0.7F;

	  if (lowerLleg.rotateAngleX > 5/rad){
		  this.lowerLleg.rotateAngleX = 5/rad; }
	  if (upperLleg.rotateAngleX < -5/rad){
		  this.upperLleg.rotateAngleX = -5/rad; }
	  
	  this.lowerbody.rotateAngleX = 0;
	  this.lowerbody.rotateAngleZ = motion/2 * 0.35F * (this.func_78172_a(time, 13.0F));
	  this.lowerbody.rotateAngleY = -motion/2 * 0.5315F * (this.func_78172_a(time, 13.0F));
	  
	  this.upperRarm.rotateAngleX = (-0.2F - 1.5F * this.func_78172_a(time, 13.0F)) * motion*0.7F;
	  this.upperRarm.rotateAngleZ = 0;//45/rad;

      this.upperLarm.rotateAngleX = (-0.2F + 1.5F * this.func_78172_a(time, 13.0F)) * motion*0.2F;
	  

	
	  //"kneecap" conditionals and limp
	  if (lowerLleg.rotateAngleX < 0){
		  this.lowerLleg.rotateAngleX = 0; }
	  if (lowerRleg.rotateAngleX < 0){
		  this.lowerRleg.rotateAngleX = 0; }
	  
	  //limp...
	  this.upperLleg.rotateAngleZ = -5/rad;
	  this.upperLleg.rotateAngleY = 6/rad;
	  this.lowerLleg.rotateAngleZ = -2/rad;
	  this.lowerLleg.rotateAngleY = 4/rad;

	  this.upperLarm.rotateAngleZ = -3/rad;
	  this.upperLarm.rotateAngleY = -6/rad;
	  this.lowerLarm.rotateAngleZ = 0;//6/rad;
	  this.lowerLarm.rotateAngleY = -8/rad;
	  

	  
	  this.head.rotateAngleZ = -(this.lowerbody.rotateAngleZ*3.5f)+6/rad;

	  
	  this.lowerbody.rotationPointY = -6F - MathHelper.sin(time * (1 * r)) * 2 * motion;
	  
	  //misc resets:
	  //this.upperLarm.rotateAngleZ = -0;// + (float) Math.sin(t*.1)*.755f;
	  
	  //not sure a timer in the model file cant bee set up.
	  //switch to using age for when t > 0?

	  //model files do not like the use of += or -=... it causes corresponding entity animations
	  //to blend into each other such that the result is about half way between all mob calculations.
	  //in fact, anything that uses the previous number will suffer, since that number probably
	  //belongs to a different entity id.
	  
	  //null target = 0, range = 1, melee = 2, tremor = 3, yank = 4, whirl = 5
	  if(a == 5) //whirl
	  {
		  this.upperbody.rotateAngleY = t*15*(.066f);//*.06125f;	  
  
		  this.upperRarm.rotateAngleZ = 0 + (float) Math.sin(t*.1)*1.3f;
		  this.upperLarm.rotateAngleZ = 0 - (float) Math.sin(t*.1)*.655f;
	  }
	  else if(a == 4) //yank
	  {
		  if(t%5 == 0) {
			  //cant do this: //TODO
		  //wall.playSound("dig.leaves", 2, 1);
		  }
	  }
	  //		TODO legs lock if stuck in trample mode while moving.
	  //result of adding seconday attack ai?
	  else if(a == 3 && t > 0) //stomp
	  {
		  this.upperRleg.rotateAngleX = (-.5F * this.func_78172_a(t*1.f, 13.0F) * 1.5F) - this.lowerbody.rotateAngleX;
		  this.lowerRleg.rotateAngleX = .5F * this.func_78172_a(t*1.f, 13.0F) * 1.5F;

		  this.lowerLleg.rotateAngleX = -.5F * this.func_78172_a(t*1.f, 13.0F) * 0.4F;
		  this.upperLleg.rotateAngleX = (.5F * this.func_78172_a(t*1.f, 13.0F) * 0.4F)  - this.lowerbody.rotateAngleX;
		  
		  if(this.upperRleg.rotateAngleX > 0) {
			  this.upperRleg.rotateAngleX = 0;
		  }
		  
		  if(this.upperLleg.rotateAngleX > 0) {
			  this.upperLleg.rotateAngleX = 0;
		  }
		  
		  if (lowerLleg.rotateAngleX < 0){
			  this.lowerLleg.rotateAngleX = 0; }
		  if (lowerRleg.rotateAngleX < 0){
			  this.lowerRleg.rotateAngleX = 0; }
		  
		  this.lowerbody.rotateAngleZ = (float) Math.sin(t*.3f)*.00823f;// .35f * (this.func_78172_a(time, 13.0F));

		  this.upperRarm.rotateAngleX = -0;
		  this.upperbody.rotateAngleY = -0;

//		  this.lowerbody.rotateAngleZ = (float)Math.sin(t*.01);
		  
	  }
	  else if(a == 2 && t > 0) //melee
	  {
		  this.upperRarm.rotateAngleX = -0 - (float) Math.sin(t*.1)*1.9f;
		  this.upperbody.rotateAngleY = -0 - (float) Math.sin(t*.1)*.4f;
		  //wall.playSound("dig.leaves", 2, 1);
	  }
	  else if(a == 1) //ranged
	  {
		  this.upperbody.rotateAngleY = 0  + (float) Math.sin(t*.1)*.2f;
		  this.head.rotateAngleZ = 6/rad + (float) Math.sin(t*.1)*.5f;

		  this.upperRarm.rotateAngleX = -75/rad - (float) Math.sin(t*.1)*.45f;
		  this.upperLarm.rotateAngleX = -37.5f/rad - (float) Math.sin(t*.1)*.45f;

		  this.lowerRarm.rotateAngleY = -60/rad + (t*5*(8f/rad)); //this looks good.
		  this.lowerLarm.rotateAngleY = 60/rad - ((t)*(6.55f/rad));//(float) Math.sin(t*.05)*(18f);
	  }
	  	  else
	  {
	  		  
		  this.upperbody.rotateAngleX = 0;
		  this.upperbody.rotateAngleY = 0;
		  this.lowerbody.rotationPointZ = 0;
		  
		  this.lowerRarm.rotateAngleY = 0;
	  }
	  
	  this.lowerbody.rotationPointY = -6;
	  this.neck.rotationPointY = 8;
	  this.upperLleg.rotationPointY = this.upperRleg.rotationPointY = 0;
	  this.upperRarm.rotationPointX = -19;
	  this.upperLarm.rotationPointX = 19;

	  //death time can be extended by overwriting the onDeathupdate method and increasing the value there.
	  int dt = wall.deathTime;
	  
	  if(dt > 0)
	  {
		  this.lowerbody.rotateAngleY = (float) (Math.sin(dt*35) * 0.1f) + (dt*12)/rad;
	  
		  this.lowerbody.rotateAngleX = (float) (0-((dt*.2)/rad));
		  this.upperRleg.rotateAngleX = this.upperLleg.rotateAngleX = -this.lowerbody.rotateAngleX * 1.5f;
		  this.upperRarm.rotateAngleX = this.upperLarm.rotateAngleX = this.neck.rotateAngleX = -this.lowerbody.rotateAngleX * 1.5f;
		  this.upperLarm.rotateAngleZ = -this.upperLarm.rotateAngleX;
		  this.upperRarm.rotateAngleZ = this.upperRarm.rotateAngleX;
		  this.head.rotateAngleY = -this.lowerbody.rotateAngleY*.5f;
		  
		  dt /= 4;
		  this.lowerbody.rotationPointY = -6-dt;
		  dt/=2;
		  this.neck.rotationPointY = 8-dt;
		  this.upperLleg.rotationPointY = this.upperRleg.rotationPointY = 0 + dt;
		  this.upperRarm.rotationPointX = -19-dt;
		  this.upperLarm.rotationPointX = 19+dt;
	  }

	  
      this.upperRshoulder.rotateAngleZ = -this.upperRarm.rotateAngleZ/2.5f;
      this.upperLshoulder.rotateAngleZ = -this.upperLarm.rotateAngleZ/2.5f;
	  
  }

private float func_78172_a(float par1, float par2)
{
    return (Math.abs(par1 % par2 - par2 * 0.5F) - par2 * 0.25F) / (par2 * 0.25F);
}
}
